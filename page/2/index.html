<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ffitas.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://ffitas.github.io/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="宋辰星">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://ffitas.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-首页">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-分类">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://ffitas.github.io/2020/11/12/es6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="宋辰星">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/12/es6/" class="post-title-link" itemprop="url">Es6</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-12 17:20:05" itemprop="dateCreated datePublished" datetime="2020-11-12T17:20:05+08:00">2020-11-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-15 15:14:17" itemprop="dateModified" datetime="2021-07-15T15:14:17+08:00">2021-07-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ex6/" itemprop="url" rel="index"><span itemprop="name">ex6</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="es6"><a href="#es6" class="headerlink" title="es6"></a>es6</h1><h2 id="promise-generator-async-await"><a href="#promise-generator-async-await" class="headerlink" title="promise/generator/async/await"></a>promise/generator/async/await</h2><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><ul>
<li>function的一种简化</li>
</ul>
<h3 id="何时用"><a href="#何时用" class="headerlink" title="何时用"></a>何时用</h3><ul>
<li>简化函数，凡是用到函数的时候就可以用</li>
</ul>
<h3 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h3><ul>
<li><p>无参数</p>
<ul>
<li>&lt;ol&gt;&lt;li&gt;（）=&gt;{&nbsp; &nbsp;}&lt;br&gt;&lt;/li&gt;&lt;/ol&gt;</li>
</ul>
</li>
<li><p>有多个参数时</p>
<ul>
<li><p>const&nbsp; fun=(a,b,c)=&gt;{&nbsp; return 函数体}</p>
<ul>
<li>注意要得到函数返回值别把return忘记</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="什么是"><a href="#什么是" class="headerlink" title="什么是"></a>什么是</h3><ul>
<li>限制用户所输入的信息，的表达式</li>
</ul>
<h3 id="什么时候用"><a href="#什么时候用" class="headerlink" title="什么时候用"></a>什么时候用</h3><ul>
<li><p>表单验证</p>
</li>
<li><p>用户名输入的时候</p>
<ul>
<li>子主题</li>
</ul>
</li>
<li><p>对于密码验证的时候</p>
</li>
</ul>
<h3 id="怎么用-1"><a href="#怎么用-1" class="headerlink" title="怎么用"></a>怎么用</h3><ul>
<li><p>起止符</p>
<ul>
<li>^ 开始符号</li>
<li>&amp;结束符</li>
</ul>
</li>
<li><p>多选一符号</p>
<ul>
<li>[  ]</li>
</ul>
</li>
<li><p>组合符号 ^[^A-Z0-9${2,3} ]</p>
<ul>
<li>后面花括号代表的是从前面选2-3个元素；</li>
</ul>
</li>
</ul>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><ul>
<li><p>const</p>
<ul>
<li><p>这个和let的最大的区别就是，const不可以先只声明</p>
<ul>
<li><p>为什么</p>
<ul>
<li>const所定义的是一个定值，如果你只声明不赋值，如何做到是一个定值，感觉有点勉强</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>let </p>
<ul>
<li>Subtopic</li>
</ul>
</li>
<li><p>它首先解决了var变量提升的问题</p>
<ul>
<li>它怎么解决这个问题的，将全局执行上下文的创建阶段和执行阶段时机同步了所以不会再出现变量提升的问题</li>
<li>它还解决了，var没有作用域的问题</li>
</ul>
</li>
<li><p>由块级作用域，引发了一个问题就是暂时性死区</p>
<ul>
<li><p>什么时候会引发暂时性死区</p>
<ul>
<li><p>条件</p>
<ul>
<li>如果在一个块级作用域里存在let,那么此时let所处的作用域就会锁死</li>
</ul>
</li>
<li><p>一旦在变量let声明前,去使用就会为undefined</p>
</li>
<li><p>那我什么时候能用，只有到声明后才可以去使用let/或const所声明的变量</p>
</li>
<li><p>那具体暂时性死区是什么</p>
<ul>
<li>其实就是let/const声明前的代码区域（在块级作用域中）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><ul>
<li><p>没有块级作用域</p>
<ul>
<li><p>那如果没有块级作用域会引发哪些问题</p>
<ul>
<li><p>在函数中用var声明的变量，函数外部可以访问，这个就很危险</p>
</li>
<li><p>也会引发变量提升的问题</p>
<ul>
<li>根据你在声明变量的时候，会出现执行上下文，而创建上下文的创建与执行阶段是不同步的所以造成了变量提升</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h2><h3 id="指向谁"><a href="#指向谁" class="headerlink" title="指向谁"></a>指向谁</h3><ul>
<li>在函数 的内部，</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=".  .   ."></a>.  .   .</h2><h3 id="实现对对象的深拷贝"><a href="#实现对对象的深拷贝" class="headerlink" title="实现对对象的深拷贝"></a>实现对对象的深拷贝</h3><h3 id="将数组转为由逗号隔开的序列，同时又可以实现拷贝"><a href="#将数组转为由逗号隔开的序列，同时又可以实现拷贝" class="headerlink" title="将数组转为由逗号隔开的序列，同时又可以实现拷贝"></a>将数组转为由逗号隔开的序列，同时又可以实现拷贝</h3><h3 id="传递形参时用"><a href="#传递形参时用" class="headerlink" title="传递形参时用"></a>传递形参时用</h3><ul>
<li>如果你并不知道参数有几个的时候？？？</li>
</ul>
<h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><h3 id="怎么用-2"><a href="#怎么用-2" class="headerlink" title="怎么用"></a>怎么用</h3><ul>
<li>需要从一些对象（也可解构多层嵌套对象）</li>
</ul>
<h3 id="说人话"><a href="#说人话" class="headerlink" title="说人话"></a>说人话</h3><ul>
<li><p>获取对象里的值</p>
<ul>
<li>根据对象里的键来获取值</li>
</ul>
</li>
</ul>
<h3 id="更高端大气"><a href="#更高端大气" class="headerlink" title="更高端大气"></a>更高端大气</h3><h2 id="怎样将类数组转为真正的数组"><a href="#怎样将类数组转为真正的数组" class="headerlink" title="怎样将类数组转为真正的数组"></a>怎样将类数组转为真正的数组</h2><h3 id="Array-from-类数组"><a href="#Array-from-类数组" class="headerlink" title="Array.from(类数组)"></a>Array.from(类数组)</h3><h3 id="除过es6以外还有什么方法"><a href="#除过es6以外还有什么方法" class="headerlink" title="除过es6以外还有什么方法"></a>除过es6以外还有什么方法</h3><ul>
<li><p>Array.prototype.slice( ).call(类数组）</p>
<ul>
<li>这个不理解</li>
</ul>
</li>
</ul>
<h2 id="Map（）"><a href="#Map（）" class="headerlink" title="Map（）"></a>Map（）</h2><h3 id="它解决了什么问题"><a href="#它解决了什么问题" class="headerlink" title="它解决了什么问题"></a>它解决了什么问题</h3><ul>
<li>专门用来存储键值对的</li>
</ul>
<h3 id="什么时候用一旦出现需要存储一对键值对，立刻首先想到Map这个数据结构"><a href="#什么时候用一旦出现需要存储一对键值对，立刻首先想到Map这个数据结构" class="headerlink" title="什么时候用一旦出现需要存储一对键值对，立刻首先想到Map这个数据结构"></a>什么时候用一旦出现需要存储一对键值对，立刻首先想到Map这个数据结构</h3><h3 id="那它有哪些方法"><a href="#那它有哪些方法" class="headerlink" title="那它有哪些方法"></a>那它有哪些方法</h3><ul>
<li><p>set(键，值）</p>
<ul>
<li>这个返回的是新的map数据结构，包含有新的设置的键值对</li>
</ul>
</li>
<li><p>has(键）</p>
<ul>
<li><p>返回值为布尔值</p>
<ul>
<li>目的是为了判断是否存在当前键//这个主要判断是否有对应的键</li>
</ul>
</li>
</ul>
</li>
<li><p>delete(键)</p>
<ul>
<li>删除键所对应的键值对</li>
</ul>
</li>
<li><p>get(键）</p>
<ul>
<li><p>这个是在获取键所对应的值</p>
<ul>
<li>这个在力扣第一题中用到它了</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set()"></a>Set()</h2><h3 id="一旦题目中涉及集合立刻想到set"><a href="#一旦题目中涉及集合立刻想到set" class="headerlink" title="一旦题目中涉及集合立刻想到set"></a>一旦题目中涉及集合立刻想到set</h3><ul>
<li>特点就是，一旦题目提到有序，无重复元素，立刻反应Set()</li>
</ul>
<h3 id="Set做了哪些事情"><a href="#Set做了哪些事情" class="headerlink" title="Set做了哪些事情"></a>Set做了哪些事情</h3><ul>
<li><p>给定一个数组</p>
<ul>
<li>返回一个没有重复序列的集合</li>
</ul>
</li>
</ul>
<h3 id="能做到什么"><a href="#能做到什么" class="headerlink" title="能做到什么"></a>能做到什么</h3><ul>
<li><p>数组去重</p>
<ul>
<li><p>首先通过，[…set(arry)]</p>
<ul>
<li>但是我对于这个有一些问题就是，首先通过…元素是否意思是将set数据结构转为数组，那如果已经是数组了为什么要在加上数组字面量不理解</li>
</ul>
</li>
</ul>
</li>
<li><p>求交集</p>
<ul>
<li>怎么做</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://ffitas.github.io/2020/09/15/HTML%E4%BD%93%E7%B3%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="宋辰星">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/15/HTML%E4%BD%93%E7%B3%BB/" class="post-title-link" itemprop="url">HTML</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-15 14:20:05" itemprop="dateCreated datePublished" datetime="2020-09-15T14:20:05+08:00">2020-09-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-15 14:48:29" itemprop="dateModified" datetime="2021-07-15T14:48:29+08:00">2021-07-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/html/" itemprop="url" rel="index"><span itemprop="name">html</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!DOCTYPE html>
<h3 id="DOCTYPE"><a href="#DOCTYPE" class="headerlink" title="DOCTYPE"></a>DOCTYPE</h3><p>DOC 是 document 文档的意思，type 是类型的意思–也就是说<strong>告诉浏览器用什么规范渲染页面</strong></p>
<ol start="2">
<li><p>从这各点可以引入[“怪异模式”]</p>
<blockquote>
<h3 id="严格模式-怪异模式"><a href="#严格模式-怪异模式" class="headerlink" title="严格模式/怪异模式"></a>严格模式/怪异模式</h3><p><strong>Doctype 的作用？标准（严格）模式，怪异（混杂）模式的区别，它们的意义？</strong></p>
<ol>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ltt2017/archive/2017/04/28/6783787.html">严格模式怪异模式的理解</a>。</li>
<li>严格模式：按照最标准的格式，来进行页面布局&amp;渲染界面。&lt;! Doctype HTML&gt; Doctype HTML Doctype HTML Doctype HTML Doctype HTML Doctype HTML Doctype HTML Doctype HTML</li>
<li>怪异模式/混杂模式： 按各个浏览器的标准来，目的：兼容旧浏览器。//这个理解</li>
<li>我个人理解就是说这个之前有些浏览器不是按照 w3c 的要求来渲染的，这就导致了这个不同浏览器渲染机制不太一样为了能够一样。</li>
</ol>
</blockquote>
<p>。</p>
</li>
</ol>
<h3 id="严格模式-怪异模式-1"><a href="#严格模式-怪异模式-1" class="headerlink" title="严格模式/怪异模式"></a>严格模式/怪异模式</h3><p><strong>Doctype 的作用？标准（严格）模式，怪异（混杂）模式的区别，它们的意义？</strong></p>
<ol>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ltt2017/archive/2017/04/28/6783787.html">严格模式怪异模式的理解</a>。</li>
<li>严格模式：按照最标准的格式，来进行页面布局&amp;渲染界面。&lt;! Doctype HTML&gt; Doctype HTML Doctype HTML Doctype HTML Doctype HTML Doctype HTML Doctype HTML Doctype HTML</li>
<li>怪异模式/混杂模式： 按各个浏览器的标准来，目的：兼容旧浏览器。//这个理解</li>
<li>我个人理解就是说这个之前有些浏览器不是按照 w3c 的要求来渲染的，这就导致了这个不同浏览器渲染机制不太一样为了能够一样。</li>
</ol>
<h3 id="HTML5-新增属性"><a href="#HTML5-新增属性" class="headerlink" title="HTML5 新增属性"></a>HTML5 新增属性</h3><ol>
<li><strong>语义化</strong>元素，比如 footer、header、nav、section，用这些语义化除了有利于代码可读性，更重要的是有利于 seo 优化,简单来讲就是，有利于爬虫爬取数据。从而提升网站的排名。</li>
<li><strong>Localstorage:</strong> 数据永久存储在浏览器缓存里，除非人为删除我在做 JWT 鉴权时将 token 值用用 localstorage 存储，SessionStorage，session 会话，也就是说，一旦，浏览器关闭，缓存就会消失。</li>
<li><strong>data</strong>-src : 特点凡是用到了 data 的都是<strong>自定义属性</strong>： –》怎么用<strong>图片懒加载</strong>：就是当需要显示的时候才会通过 js 获取 data-src:里的真实地址，然后在赋值给 Img 里的 src;</li>
<li>canvas 画布</li>
<li>video audio ,嵌入视频和音频。更动感。</li>
</ol>
<h4 id="记忆方法"><a href="#记忆方法" class="headerlink" title="记忆方法"></a>记忆方法</h4><ol>
<li>我无（5）语（语义化）了（L），需要看好看的图片（data-src),画布（canves）和视频(audio)来缓解。</li>
</ol>
<h3 id="iframe。"><a href="#iframe。" class="headerlink" title="iframe。"></a>iframe。</h3><h4 id="叙述思路"><a href="#叙述思路" class="headerlink" title="叙述思路"></a>叙述思路</h4><ol>
<li>首先最重要的一点就是说会影响 <strong>seo</strong>，爬虫不识别</li>
<li>阻塞 Onload 事件。意思就是所有的，资源加载完毕，并且等待 iframe 页面加载完毕后才会去执行 onload，所以会阻塞。</li>
<li>影响并行加载，iframe 的页面和主页面在同一个域名下，他们之间是并行加载关系，而浏览器资源有限，所以影响。</li>
<li>怎么改善就是说通过 js 动态给 iframe 设置页面地址。</li>
</ol>
<h3 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h3><p>[文档流.emmx]</p>
<h3 id="如何来清除浮动"><a href="#如何来清除浮动" class="headerlink" title="如何来清除浮动"></a>如何来清除浮动</h3><ol>
<li>联想 clear，看见这个清除，联想 <strong>clear</strong></li>
<li>clear: both. //额外标签法，在最后一个浮动元素后，设置一个额外的标签然后，再去设置 clear:both //创造了额外标签，语义化不好。</li>
<li>清除元素，这个是最优的，因为，给父元素上用的，防止其高度塌陷伪元素独立于 dom 树之外，所以它不会去参与 dom 树的构建，```//它没有添加额外标签，也没有像这个 overflowhidden：有副作用。这个不要把::伪类元素给忘记了，就是这个就是模拟的这个，额外标签的方法，但是这个伪元素又是独立于文档树之外的。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> .clearfix ：：after&#123;</span><br><span class="line">content=&#x27;&#x27;;</span><br><span class="line">display: block; //类似于创造了一个额外的标签进行清除浮动，//并且由于这个伪元素是行内元素所以需要转为这个块级元素。</span><br><span class="line">clear:both;  //:after选择符IE 6不支持，也就是说上面的这段代码在IE 6中无效，这怎么办？</span><br><span class="line">我们添加一条IE 6的独有命令&quot;zoom:1;&quot;就行了，这条命令的作用是激活父元素的&quot;hasLayout&quot;属性，让父元素拥有自己的布局。IE 6会读取这条命令，其他浏览器则会直接忽略它。</span><br></pre></td></tr></table></figure></li>
<li>还有 overflow:hidden 原理是给父元素利用触发了 bfc 块， 它计算高度的时候是考虑浮动元素的高度的，所以可以去清除这个浮动。</li>
</ol>
<h3 id="a-标签的-4-个伪类的正确顺序，并解释"><a href="#a-标签的-4-个伪类的正确顺序，并解释" class="headerlink" title="a 标签的  4 个伪类的正确顺序，并解释"></a>a 标签的  4 个伪类的正确顺序，并解释</h3><ol>
<li>LVHA ：（层级覆盖的原理）就是:hover 必须要放最后，这样做能够确保让用户知道这个元素是可以访问的所以这个必须放在最后面。然后 link 就是有链接就有样式，:visited 为了区别这个链接是否被访问，这个放其后，a 和 h 的关系随意，一个是鼠标放上去，一个是点击，但是弹起中的触发，所以两者不会冲突。</li>
</ol>
<h3 id="bfc"><a href="#bfc" class="headerlink" title="bfc"></a>bfc</h3><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/mevicky/article/details/47008939">bfc 理解</a>。</li>
<li>设置 BFC 时候，display 可以设置成什么</li>
</ol>
<h3 id="DOM-事件体系，冒泡"><a href="#DOM-事件体系，冒泡" class="headerlink" title="DOM 事件体系，冒泡"></a>DOM 事件体系，冒泡</h3><ol>
<li>哪些事件没有冒泡：不支持冒泡：妈（mouseenter）妈(mouseleave)不(blur)放(focus)心你(unload,load,resize)。</li>
<li>事件委托就是依赖于，捕获冒泡的原理来解决这个问题的，通过不断的冒泡 [DOM 事件体系，及冒泡事件委托.emmx]</li>
</ol>
<h3 id="meta-标签"><a href="#meta-标签" class="headerlink" title="meta 标签"></a>meta 标签</h3><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><ol>
<li>凡是布局首先应该联想到这个，浮动，flex 定位，bfc。</li>
</ol>
<h4 id="两栏布局"><a href="#两栏布局" class="headerlink" title="两栏布局"></a>两栏布局</h4><ol>
<li>左列定宽，右列自适应，定位，就是右边的定位为 left 为左边定宽的距离，上右都为 0 这样就可以了。</li>
<li>flex 就是父级 flex 布局，然后，flex- grow =1 就可以让剩余的元素来，填充剩下的内容。</li>
<li>浮动布局–》当需要两个元素同属一行的时候就应该想到然后，就是块级元素默认是 100% 宽度，所以只让左定宽元素去浮动，右元素仅仅去设置左边距，本身就是 100% 宽度。</li>
</ol>
<h4 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h4><ol>
<li><p>左右两列定宽，右列自适应。就可以利用[“BFC 块”</p>
<blockquote>
<h3 id="BFC-块-IFC"><a href="#BFC-块-IFC" class="headerlink" title="BFC 块 /IFC"></a>BFC 块 /IFC</h3><h4 id="为什么设置-over-flow-hidden-可以清除浮动"><a href="#为什么设置-over-flow-hidden-可以清除浮动" class="headerlink" title="为什么设置 over-flow:hidden,可以清除浮动"></a>为什么设置 over-flow:hidden,可以清除浮动</h4><ol>
<li>要了解 bfc 块，内部的块级元素会垂直摆放，同属于一个 bfc 块会发生 margin 重叠，那么消除这样的 bug 就可以给其中一个元素在套一个容器让他成为令一个新的 bfc 块（还要设置一个 over-flow:hidden).</li>
<li>给父元素加了一个 over-flow:hidden 就是为了使用 bfc 块的特性：在计算 bfc 块的高度时会计算里面浮动元素的高度，这样看上去就把浮动元素包裹了起来。</li>
<li>注意一下如何使用 BFC 消除 margin 重叠，</li>
<li>首先你要去明确就是重叠这个现象只出现在垂直的方向，水平方向是没有的</li>
<li>overflow:hidden;bfc 块的特性就是，紧贴浮动元素，所以直接就在两边。也可以用来去做这个浮动元素。</li>
<li><strong>可以触发 BFC</strong> 的属性有 float、position、overflow、display：table-cell/ inline-block/table-caption</li>
</ol>
<h4 id="IFC"><a href="#IFC" class="headerlink" title="IFC"></a>IFC</h4><ol>
<li>IFC（Inline formatting contexts）：<strong>内联格式上下文</strong> IFC 的 line box（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的 padding/margin 影响)IFC 中的 line box 一般左右都贴紧整个 IFC，但是会因为 float 元素而扰乱。float 元素会位于 IFC 与与 line box 之间，使得 line box 宽度缩短。 同个 ifc 下的多个 line box 高度会不同 IFC 中时不可能有块级元素的，当插入块级元素时（如 p 中插入 div）会产生两个匿名块与 div 分隔开，即产生两个 IFC，每个 IFC 对外表现为块级元素，与 div 垂直排列。 那么 IFC 一般有什么用呢？ <strong>水平居中</strong>：当一个块要在环境中水平居中时，设置其为 inline-block 则会在外层产生 IFC，通过 text-align 则可以使其水平居中。 <strong>垂直居中</strong>：创建一个 IFC，用其中一个元素撑开父元素的高度，然后设置其 vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。</li>
</ol>
</blockquote>
<p> 的特点：紧贴着浮动的元素，</p>
</li>
<li><p>就是定义页面元信息，告诉机器如何渲染页面的，方便搜索引擎，有利于 seo 优化的。</p>
</li>
<li><p>比如 name:viewport 移动端布局的，告诉机器如何来渲染界面。</p>
</li>
<li><p>比如申明文档的编码格式为 UTF-8 等。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://ffitas.github.io/2020/08/19/TCP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="宋辰星">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/19/TCP/" class="post-title-link" itemprop="url">TCP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-19 15:20:05" itemprop="dateCreated datePublished" datetime="2020-08-19T15:20:05+08:00">2020-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-15 15:19:37" itemprop="dateModified" datetime="2021-07-15T15:19:37+08:00">2021-07-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TCP/" itemprop="url" rel="index"><span itemprop="name">TCP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="如何来理解-tcp-是面向流的"><a href="#如何来理解-tcp-是面向流的" class="headerlink" title="如何来理解 tcp 是面向流的"></a>如何来理解 tcp 是面向流的</h3><ol>
<li><p>所谓的流就是说无<a href="siyuan://blocks/20210130110417-7sbw2pb">“消息保护边界的”</a></p>
<blockquote>
<ol>
<li>由于 tcp 无消息保护边界，（个人理解就是不知道消息从哪里开始，也不知道消息从哪里结束）需要在接收端来处理消息边界问题，这也就是说粘包，拆包问题。</li>
<li>什么是粘包，就是说有可能两个信息包，粘在了一起</li>
<li>有些包被拆成几块因为大于了 MSS,所以需要拆包，，然后与其它包粘在一起。</li>
</ol>
</blockquote>
<p>，这里通俗理解就是说接受方无法去界定这个消息的开始和结尾，而有消息保护边界就是说消息之间是独立的，因为消息与消息之间有边界。</p>
</li>
</ol>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ol>
<li>首先（先联想图）客户端向服务器发出序列号 SYN ，seq（随机发出一个序列号）</li>
<li>服务器收到后会基于客户端的序列号，发出一个 ACK 确认号。为了表示一个回礼，还需要发 Seq</li>
<li>客户端会再次对服务器的序列号产生一个确认。</li>
</ol>
<h3 id="为什么建立连接是三次，而不是两次。"><a href="#为什么建立连接是三次，而不是两次。" class="headerlink" title="为什么建立连接是三次，而不是两次。"></a>为什么建立连接是三次，而不是两次。</h3><h4 id="防止历史请求初始化-tcp-连接"><a href="#防止历史请求初始化-tcp-连接" class="headerlink" title="防止历史请求初始化 tcp 连接"></a>防止历史请求初始化 tcp 连接</h4><ol>
<li><strong>反向验证两次为什么不行</strong>：如果只有两次，客户端这里对于服务器发来的报文，无法来判断这个报文是否有效（是否过期，是否超时）因为网路拥塞这样的事情很常见。</li>
<li>所以客户端这里没有足够的<strong>上下文</strong>来判断，是否是如期的请求。</li>
<li>此时从三次说，那为什么三次避免了这样的问题，当客户端收到服务器的请求的时候，<strong>客户端</strong>本身会<strong>存储</strong>自己所发出的<strong>序列号</strong>，所以可以依据所收到的 ack 来判断是否是如期的，如果是就正常连接。</li>
<li>但如果不是，那就发送 <strong>RST</strong> （有重置的意思）报文，来结束这个连接。</li>
</ol>
<h4 id="确认彼此的系列号"><a href="#确认彼此的系列号" class="headerlink" title="确认彼此的系列号"></a>确认彼此的系列号</h4><ol>
<li>其实 tcp 能够实现可靠连接的本质其实是能够确认彼此的序列号，那你如果只有两次，只能单向确认，无法互相确认，所以需要三次。</li>
</ol>
<h4 id="防止（服务器）资源浪费"><a href="#防止（服务器）资源浪费" class="headerlink" title="防止（服务器）资源浪费"></a>防止（服务器）资源浪费</h4><ol>
<li>由于仅有两次，服务器是没有办法判断对方是否收到了正确的序号</li>
<li>客户端如果因为网路阻塞，发出了多个 SYN 信号，那客户端有可能收到，也有可能收不到，所以为了确保对方收到，服务器只能建立多个重复的 tcp 链接。极大的浪费资源。</li>
</ol>
<h4 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h4><ol>
<li>（首先看到<strong>四</strong>先想想哪四次，<strong>两对 FIN-ACK</strong> ，为什么一定要四次，就是说客户端向服务器先发 FIN 表示两个人关系淡了想分了，所以<strong>发出 FIN 终止报文</strong>。</li>
<li>服务区器先对终止报文发出确认</li>
<li>但服务器收到还可能对收到的信进行处理并发送，意味着此时不能立刻终止关系。</li>
<li>在处理完信息后再去发出 FIN，自身进入 closed 状态。</li>
<li>客户端收到信息后再次，向服务器发出一个 ACK,后它不会立刻进入到 closed 状态，它需要等待两个 <strong>MSL</strong>（最大报文生存时间）为什么是两个主要是因为网络时常会发生阻塞，对方没有收到一个 ACK,客户端会重发，那么重发之后一个来回就对应了两个 MSL。第二个原因：<a target="_blank" rel="noopener" href="https://blog.csdn.net/LF_2016/article/details/60468161">防止历史报文骚扰服务器</a>。</li>
<li><a target="_blank" rel="noopener" href="http://www.bubuko.com/infodetail-3143286.html">易理解第二个原因</a></li>
<li>补充：TIME——wait 等待过程。</li>
</ol>
<h3 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h3><h5 id="知道滑动窗口不，客户端和服务端控制滑动窗口的过程是怎样的。"><a href="#知道滑动窗口不，客户端和服务端控制滑动窗口的过程是怎样的。" class="headerlink" title="知道滑动窗口不，客户端和服务端控制滑动窗口的过程是怎样的。"></a>知道滑动窗口不，客户端和服务端控制滑动窗口的过程是怎样的。</h5><ol>
<li>（此处联想 tcp 连接的一个过程）首先滑动窗口受限于接收方的接收能力大小，就是发送方每发送数据后，服务器就会去移动滑动窗口的指针，之后可用窗口会减小，并且会将当前可用窗口的大小发送给客户端，用来控制发送方发送的数据量以达到，流量控制。</li>
</ol>
<p><strong>讲述思路：</strong></p>
<ol>
<li>首先想到滑动窗口首先<strong>联想接收方有一个滑动窗口</strong>，也就是说这个主要是和接收方有关，防止对方发送的数据超出了接收方的数据。</li>
</ol>
<h5 id="发送窗口和接收窗口分别由哪些构成"><a href="#发送窗口和接收窗口分别由哪些构成" class="headerlink" title="发送窗口和接收窗口分别由哪些构成"></a>发送窗口和接收窗口分别由哪些构成</h5><ol>
<li>发送窗口：由<strong>发送</strong>想到了<strong>已发送</strong>到并得到确认的字段区域，那有得到确认的自然还有<strong>没有接收到确认的</strong>，<strong>可用窗口</strong>，那由于自身肯定还有好多数据好多话想告诉接收方所以自然还会有许多数据等待发送，但是这个会超出对方的接收范围。也就 是<strong>不可用窗口</strong>。（两个发送，可不可以）4 个</li>
<li>接收方窗口：已经接受到的数据并确认，<strong>理解有一个误区就是说接收方没有接收到数据但是没有得到确认的</strong>，发送方有是因为它自己是发送数据的，接收到的 ack 是有可能阻塞的，未确认，接收方不考虑这个，只管接收就好。<strong>还有未接收到，并是可接受范围内</strong>，<strong>未接收但是，超出了可用窗口大小的区域</strong>。（三个）</li>
</ol>
<h5 id="那你知道滑动窗口和拥塞窗口有什么区别不"><a href="#那你知道滑动窗口和拥塞窗口有什么区别不" class="headerlink" title="那你知道滑动窗口和拥塞窗口有什么区别不"></a>那你知道滑动窗口和拥塞窗口有什么区别不</h5><ol>
<li>由拥塞想到了网络拥塞，也就是说主要应用于解决网络拥塞问题的，主要由发送方控制，防止它发多了导致了网络拥塞。</li>
<li>而滑动窗口主要是因为解决防止发送方数据量超过了接收方的能力，也就是说其大小取决于接收方。</li>
</ol>
<h3 id="如果对方问到这个-tcp-流量控制我该怎么回答"><a href="#如果对方问到这个-tcp-流量控制我该怎么回答" class="headerlink" title="如果对方问到这个 tcp 流量控制我该怎么回答"></a>如果对方问到这个 tcp 流量控制我该怎么回答</h3><ol>
<li>流量控制依赖于<strong>滑动窗口</strong>来控制发送方发送的速率不要太快（联想一个窗口，里面有有两个指针，然后再作答）</li>
<li><img src="assets/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_2021-03-18_085843-20210318085932-amu0bbp.png" alt="屏幕截图_2021-03-18_085843.png">。</li>
<li>你怎么理解这个窗口就是缓存区的<strong>剩余</strong>大小，只有收到确认才能将已经发送的数据进行发送。</li>
<li>所谓的流量控制其实就是面试以服务端发送举例子（此时假定发送窗口可接收窗口都不变的情况），客户端接收做例子，这里我概括说就是，每当服务器发送完数据后，相应的可用窗口大小就会减少，相对应的指针也会发送变化，就是 snd.next 指向的是<strong>可用窗口</strong>大小的头指针，右移，当收到了对方的<strong>确认</strong>后，自生的 snd.una 也会右移，那么此时可用窗口大小自然增大。</li>
<li>此时接收方再接收到信息后 rsv.next,也会发送移动，如果发送方的数据超过了其可用窗口就会导致窗口关闭也就是说起到了<strong>流量控制</strong>。在接收到接收方的确认后才可以据悉的发送数据。</li>
<li>实际上如果应用层没有及时的读取缓存区里的数据就会导致，每次接收方接收到数据后，其<strong>接收</strong>窗口大小会变得更小，并且会将这个大小以 <strong>window 字段</strong>来告诉，发送方来达到流量控制，以此控制发送方的速率。</li>
<li>但是窗口大小其实会动态变化的，如果先减少了接收缓存区，又收缩了窗口，最终没有多余接收缓存，可以接收数据，就会导致丢包，那为了解决这个问题，就是先<strong>来收缩窗口</strong>，再去<strong>减少</strong>接收缓存。（这里就是说这个，窗口）</li>
<li>窗口局面就是说如果说在窗口关闭后，应用应用进程如果没有及时读取缓冲区里的数据会导致窗口收缩，</li>
<li>那么在窗口关闭后应用进程及时读取消息，就会恢复其接收窗口大小，并且会通知发送方以 window 字段，但是这里有一个问题就是，如果这个消息丢失了，就会导致，<strong>死锁</strong>现象。</li>
<li><strong>坚持定时器</strong>，就是一旦接收方窗口大小变为 0 就会启动，并每隔一段时间来进行探测报文探测对方目前可用窗口大小，这样就可以来避免死锁了。</li>
</ol>
<h3 id="糊涂窗口"><a href="#糊涂窗口" class="headerlink" title="糊涂窗口"></a>糊涂窗口</h3><ol>
<li>糊涂窗口就是为了<strong>避免</strong>发送方发送<strong>小数据</strong>，因为 tcp ip 头部太大为了发送小数据而导致资源浪费。</li>
<li>一般采取 Nagle 算法来解决就是通过这个 1：只有当窗口值<strong>大于 MSS</strong>，的长度，以及收到之前数据的<strong>确认</strong>之前，一直再囤积想要发送的数据。</li>
</ol>
<h3 id="拥塞控制（联想折线上升图）"><a href="#拥塞控制（联想折线上升图）" class="headerlink" title="拥塞控制（联想折线上升图）"></a>拥塞控制（联想折线上升图）</h3><ol>
<li>首先来复盘一下自己的知识点，就是首先由拥塞想到了为什么拥塞窗口也就是说 crwd,</li>
<li>那么也就是说所谓的拥塞窗口主要是来解决网络拥塞的。</li>
<li>那么首先达到慢启动阶段，以指数增加。<a target="_blank" rel="noopener" href="https://blog.csdn.net/linweixuan/article/details/4353015">慢启动为什么是指数增加</a>。</li>
<li>之后到达了门限值，之后进入了拥塞避免阶段，每接收到一个 ack 就拥塞窗口加拥塞窗口分之一。线性增加</li>
<li>但是还是会拥塞，先有超时重传，门限值减半，拥塞窗口初始化为 1</li>
<li>还有一种就是快重传会接收到三个重复的 ack，cwnd 减半，然后门限值为拥塞窗口一半，到达快恢复后，其拥塞窗口在此基础上加三（三个重复的 ack）。</li>
</ol>
<h3 id="粘包拆包问题"><a href="#粘包拆包问题" class="headerlink" title="粘包拆包问题"></a>粘包拆包问题</h3><h3 id="tcp-粘包，"><a href="#tcp-粘包，" class="headerlink" title="tcp 粘包，"></a>tcp 粘包，</h3><ol>
<li>由于 tcp 无消息保护边界，（个人理解就是不知道消息从哪里开始，也不知道消息从哪里结束）需要在接收端来处理消息边界问题，这也就是说粘包，拆包问题。</li>
<li>什么是粘包，就是说有可能两个信息包，粘在了一起</li>
<li>有些包被拆成几块因为大于了 MSS,所以需要拆包，，然后与其它包粘在一起。</li>
</ol>
<h3 id="为什么会出现这个奇怪的现象"><a href="#为什么会出现这个奇怪的现象" class="headerlink" title="为什么会出现这个奇怪的现象"></a>为什么会出现这个奇怪的现象</h3><ol>
<li>对于接受方就是，<strong>接受数据到缓存的</strong>速率<strong>大于</strong>了<strong>应用进程读取数据</strong>的速率，就会导致多个包粘连在一起。</li>
<li>发送方的 Nagel 算法。导致出现了在接收到一个确认后，收集多个分组数据再去发送。/粘包。</li>
</ol>
<p>怎么解决这个问题</p>
<ol>
<li>发送方 去关闭 nagel 算法。</li>
<li>由于接收方不清楚，一个完整消息的大小，所以发送端会给数据包，<strong>添加一个包首部</strong>，这个首部，会<strong>包含数据包的长度</strong>，这样接收方通过首部消息就可以知道了类似于有了消息边界。</li>
<li>发送端将每个数据包大小固定，这样接收方就可以知道这个了。</li>
<li>也可以在<strong>数据包之间设置边界</strong>，如添加特殊的符号，接收方就可以清楚一个完整数据包的大小了。</li>
</ol>
<h3 id="tcp-重传机制"><a href="#tcp-重传机制" class="headerlink" title="tcp 重传机制"></a>tcp 重传机制</h3><ol>
<li>D-SACK<br>[http tcp](assets/http tcp.pdf?page=65).</li>
</ol>
<h3 id="tcp-的包一定是按照顺序的吗"><a href="#tcp-的包一定是按照顺序的吗" class="headerlink" title="tcp 的包一定是按照顺序的吗"></a>tcp 的包一定是按照顺序的吗</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jiujiu372/article/details/76855199">tcp 的包一定是按照顺序的吗</a></p>
<p><a href="https://"></a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://ffitas.github.io/2020/07/19/websocket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="宋辰星">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/19/websocket/" class="post-title-link" itemprop="url">websocket</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-19 14:20:05" itemprop="dateCreated datePublished" datetime="2020-07-19T14:20:05+08:00">2020-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-15 15:21:08" itemprop="dateModified" datetime="2021-07-15T15:21:08+08:00">2021-07-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTTP/" itemprop="url" rel="index"><span itemprop="name">HTTP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h1><h2 id="它解决了http是半双工，实现了服务端推送"><a href="#它解决了http是半双工，实现了服务端推送" class="headerlink" title="它解决了http是半双工，实现了服务端推送"></a>它解决了http是半双工，实现了服务端推送</h2><h3 id="也就是说客户端和服务器之间无法，随意互相发送数据，只能是客户端，发，服务器去接受，服务器无法主动发送数据，只能是被动的"><a href="#也就是说客户端和服务器之间无法，随意互相发送数据，只能是客户端，发，服务器去接受，服务器无法主动发送数据，只能是被动的" class="headerlink" title="也就是说客户端和服务器之间无法，随意互相发送数据，只能是客户端，发，服务器去接受，服务器无法主动发送数据，只能是被动的"></a>也就是说客户端和服务器之间无法，随意互相发送数据，只能是客户端，发，服务器去接受，服务器无法主动发送数据，只能是被动的</h3><h2 id="那为了能够实现类似全双工的效果，http做出了哪些努力，"><a href="#那为了能够实现类似全双工的效果，http做出了哪些努力，" class="headerlink" title="那为了能够实现类似全双工的效果，http做出了哪些努力，"></a>那为了能够实现类似全双工的效果，http做出了哪些努力，</h2><h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><ul>
<li>其实就是说，客户端会向服务器不断的发送询问，问是否有新的数据，那么很明显这样做，效率非常的低</li>
</ul>
<h3 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h3><ul>
<li>意思就是说只有对方有数据才会发，每次客户端仅在接受到新数据才会去询问，如果，没有那就不询问了</li>
</ul>
<h2 id="那么websocket是怎么来建立连接的（握手）"><a href="#那么websocket是怎么来建立连接的（握手）" class="headerlink" title="那么websocket是怎么来建立连接的（握手）"></a>那么websocket是怎么来建立连接的（握手）</h2><h3 id="其实首先初始本质就是一个http的get-请求（之所以这样做其实是为了能够，绕过浏览器，防火墙的限制，因为这样做，但是这里为了能够告诉服务器其实并不是http协议，会加入两个字段：并且还会加入一些验证消息，目的就是为了能够防止误连接"><a href="#其实首先初始本质就是一个http的get-请求（之所以这样做其实是为了能够，绕过浏览器，防火墙的限制，因为这样做，但是这里为了能够告诉服务器其实并不是http协议，会加入两个字段：并且还会加入一些验证消息，目的就是为了能够防止误连接" class="headerlink" title="其实首先初始本质就是一个http的get 请求（之所以这样做其实是为了能够，绕过浏览器，防火墙的限制，因为这样做，但是这里为了能够告诉服务器其实并不是http协议，会加入两个字段：并且还会加入一些验证消息，目的就是为了能够防止误连接"></a>其实首先初始本质就是一个http的get 请求（之所以这样做其实是为了能够，绕过浏览器，防火墙的限制，因为这样做，但是这里为了能够告诉服务器其实并不是http协议，会加入两个字段：并且还会加入一些验证消息，目的就是为了能够防止误连接</h3><h3 id="建立了连接，并且确认了就是websocket协议，之后客户端和服务器之间就可以随意互发信息了"><a href="#建立了连接，并且确认了就是websocket协议，之后客户端和服务器之间就可以随意互发信息了" class="headerlink" title="建立了连接，并且确认了就是websocket协议，之后客户端和服务器之间就可以随意互发信息了"></a>建立了连接，并且确认了就是websocket协议，之后客户端和服务器之间就可以随意互发信息了</h3><h2 id="这个协议更多的是对http的一种优化"><a href="#这个协议更多的是对http的一种优化" class="headerlink" title="这个协议更多的是对http的一种优化"></a>这个协议更多的是对http的一种优化</h2><h2 id="二进制帧格式？"><a href="#二进制帧格式？" class="headerlink" title="二进制帧格式？"></a>二进制帧格式？</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://ffitas.github.io/2020/07/12/css/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="宋辰星">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/12/css/" class="post-title-link" itemprop="url">垃圾回收机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-12 10:20:05" itemprop="dateCreated datePublished" datetime="2020-07-12T10:20:05+08:00">2020-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-15 15:13:17" itemprop="dateModified" datetime="2021-07-15T15:13:17+08:00">2021-07-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/css/" itemprop="url" rel="index"><span itemprop="name">css</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="css"><a href="#css" class="headerlink" title="css"></a>css</h1><h2 id="盒模型宽度如何计算"><a href="#盒模型宽度如何计算" class="headerlink" title="盒模型宽度如何计算"></a>盒模型宽度如何计算</h2><h3 id="offeset"><a href="#offeset" class="headerlink" title="offeset"></a>offeset</h3><ul>
<li>Subtopic</li>
</ul>
<h3 id="client"><a href="#client" class="headerlink" title="client"></a>client</h3><ul>
<li>子主题</li>
</ul>
<h3 id="盒模型计算"><a href="#盒模型计算" class="headerlink" title="盒模型计算"></a>盒模型计算</h3><ul>
<li><p>标准盒模型</p>
<ul>
<li>box-sizing: content:box</li>
</ul>
</li>
<li><p>怪异盒模型（ie）</p>
<ul>
<li>box-sizing: borderbox</li>
<li>应用边界问题</li>
</ul>
</li>
</ul>
<h2 id="margin-纵向重叠"><a href="#margin-纵向重叠" class="headerlink" title="margin-纵向重叠"></a>margin-纵向重叠</h2><h3 id="在练习布局的时候经常会有这个问题，就是说，上下元素的margin-会发生重叠"><a href="#在练习布局的时候经常会有这个问题，就是说，上下元素的margin-会发生重叠" class="headerlink" title="在练习布局的时候经常会有这个问题，就是说，上下元素的margin 会发生重叠"></a>在练习布局的时候经常会有这个问题，就是说，上下元素的margin 会发生重叠</h3><h3 id="再具体来讲就是margin-top-margin-bottom-margin-top-bottom"><a href="#再具体来讲就是margin-top-margin-bottom-margin-top-bottom" class="headerlink" title="再具体来讲就是margin-top+margin-bottom !== margin(top+bottom)"></a>再具体来讲就是margin-top+margin-bottom !== margin(top+bottom)</h3><h3 id="所谓的重叠就是纵方向的margin会重叠在一起取值最大的margin"><a href="#所谓的重叠就是纵方向的margin会重叠在一起取值最大的margin" class="headerlink" title="所谓的重叠就是纵方向的margin会重叠在一起取值最大的margin"></a>所谓的重叠就是纵方向的margin会重叠在一起取值最大的margin</h3><h3 id="怎么来解决这个问题"><a href="#怎么来解决这个问题" class="headerlink" title="怎么来解决这个问题"></a>怎么来解决这个问题</h3><h2 id="margin负值"><a href="#margin负值" class="headerlink" title="margin负值"></a>margin负值</h2><h3 id="这里联想一个图，就是，有上下左右四个边距，然后，向上和左元素自身会发生移动，对于下和右就是相应位置将不占高和宽，自身不会变动。换言之其它元素会进行移动占据其空缺位置。"><a href="#这里联想一个图，就是，有上下左右四个边距，然后，向上和左元素自身会发生移动，对于下和右就是相应位置将不占高和宽，自身不会变动。换言之其它元素会进行移动占据其空缺位置。" class="headerlink" title="这里联想一个图，就是，有上下左右四个边距，然后，向上和左元素自身会发生移动，对于下和右就是相应位置将不占高和宽，自身不会变动。换言之其它元素会进行移动占据其空缺位置。"></a>这里联想一个图，就是，有上下左右四个边距，然后，向上和左元素自身会发生移动，对于下和右就是相应位置将不占高和宽，自身不会变动。换言之其它元素会进行移动占据其空缺位置。</h3><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><h3 id="块级格式化上下文"><a href="#块级格式化上下文" class="headerlink" title="块级格式化上下文"></a>块级格式化上下文</h3><h3 id="独立的容器"><a href="#独立的容器" class="headerlink" title="独立的容器"></a>独立的容器</h3><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ul>
<li>margin纵向重叠的问题</li>
<li>还有就是三栏布局（两列定宽）中间自适应，中间元素，加入overflow:hidden；就可以解决这个问题，因为独立容器就是紧贴着浮动的元素。这里没有必要去给父元素设置，因为浮动元素设置，是为了计算子元素的宽高的。</li>
<li>清除浮动，原理就是bfc块是计算浮动元素高度的。</li>
</ul>
<h3 id="怎么来触发"><a href="#怎么来触发" class="headerlink" title="怎么来触发"></a>怎么来触发</h3><ul>
<li><p>浮动</p>
</li>
<li><p>非overflow: visible</p>
</li>
<li><p>定位元素：absolute, fix 首先都会脱离文档流</p>
<ul>
<li>区别：absolute相对于最近的非staic定位元素进行定位也就是说定位元素，而fix是定死在浏览器窗口内不会随着滚动条的滚动而滚动</li>
</ul>
</li>
<li><p>flex元素就是设置了display；flex布局的元素</p>
</li>
</ul>
<h3 id="联想一个场景，就是两个元素，就是上下margin重叠，并且，还有一个场景就是一个容器因为子容器浮动而高度塌陷。"><a href="#联想一个场景，就是两个元素，就是上下margin重叠，并且，还有一个场景就是一个容器因为子容器浮动而高度塌陷。" class="headerlink" title="联想一个场景，就是两个元素，就是上下margin重叠，并且，还有一个场景就是一个容器因为子容器浮动而高度塌陷。"></a>联想一个场景，就是两个元素，就是上下margin重叠，并且，还有一个场景就是一个容器因为子容器浮动而高度塌陷。</h3><h2 id="Float布局"><a href="#Float布局" class="headerlink" title="Float布局"></a>Float布局</h2><h3 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h3><ul>
<li><p>这里有个之前忽略的点就是用</p>
<ul>
<li>clear:both来清楚浮动</li>
</ul>
</li>
<li><p>这里有一个之前没有搞清楚的一点就是：这里用到了margin负值</p>
<ul>
<li>如果你给一个浮动元素，负值且为100%的话，它其实是相对于父元素的，去向左来位移的</li>
</ul>
</li>
<li><p>加深了对于position:relative理解</p>
<ul>
<li><p>这个是相对于自身来定位的什么意思就是说，当给一个设置lerelative的元素设置了top,left,right,时它会相对于自身左上角那个顶点进行移动</p>
</li>
<li><p>之前一直只是单纯用子绝父相，很少来单独的使用，relative</p>
</li>
<li><p>它的移动不会去干扰其它的布局元素也就是说，加了realtive的元素相当于不存在一样，它干扰不了其它布局的元素，其它元素的布局该是啥就是啥</p>
<ul>
<li>但我这里有一个问题就是到底，脱流的元素是否会被影响，我看中间的center 会被影响</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h3><ul>
<li><p>原因</p>
<ul>
<li>中间元素优先取渲染因为优先级更高一些</li>
</ul>
</li>
</ul>
<h3 id="为什么用"><a href="#为什么用" class="headerlink" title="为什么用"></a>为什么用</h3><h3 id="主要用于pc"><a href="#主要用于pc" class="headerlink" title="主要用于pc"></a>主要用于pc</h3><h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><h3 id="联想：clear-清除"><a href="#联想：clear-清除" class="headerlink" title="联想：clear(清除)"></a>联想：clear(清除)</h3><h3 id="clear-both-额外标签法：就是给最后一个浮动元素后添加额外的标签，然后再去clear-both"><a href="#clear-both-额外标签法：就是给最后一个浮动元素后添加额外的标签，然后再去clear-both" class="headerlink" title="clear:both 额外标签法：就是给最后一个浮动元素后添加额外的标签，然后再去clear:both"></a>clear:both 额外标签法：就是给最后一个浮动元素后添加额外的标签，然后再去clear:both</h3><h3 id="overflow-hidden"><a href="#overflow-hidden" class="headerlink" title="overflow:hidden"></a>overflow:hidden</h3><h3 id="clear-fix"><a href="#clear-fix" class="headerlink" title="clear:fix"></a>clear:fix</h3><ul>
<li>原理类似于这个clear:both,先创建一个空元素，然后再去转换为块级元素，因为伪元素是一个行内元素，类似额外标签，但是内容是空的，然后再去清除浮动。</li>
<li>content: ‘ ‘</li>
<li>dispaly: block</li>
<li>clear:both</li>
</ul>
<h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><h3 id="哪些属性"><a href="#哪些属性" class="headerlink" title="哪些属性"></a>哪些属性</h3><ul>
<li><p>flex-direction</p>
<ul>
<li>子元素布局方向要么raw column</li>
</ul>
</li>
<li><p>justify-content</p>
<ul>
<li>space-between</li>
<li>Subtopic</li>
</ul>
</li>
<li><p>align-item</p>
</li>
<li><p>wrap</p>
</li>
<li><p>align-self</p>
<ul>
<li>按照当前主轴方向的垂直方向进行排列</li>
<li>center</li>
<li>start</li>
<li>end</li>
</ul>
</li>
</ul>
<h3 id="怎么形成弹性布局"><a href="#怎么形成弹性布局" class="headerlink" title="怎么形成弹性布局"></a>怎么形成弹性布局</h3><h2 id="垂直水平居中"><a href="#垂直水平居中" class="headerlink" title="垂直水平居中"></a>垂直水平居中</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">宋辰星</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">宋辰星</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
